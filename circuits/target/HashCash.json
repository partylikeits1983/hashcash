{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":12860542902089160137,"abi":{"parameters":[{"name":"prev_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"solution","type":{"kind":"field"},"visibility":"private"},{"name":"_address","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            /*@safety  : the msg_block is checked below in verify_msg_block*/\n            build_msg_block(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            //@safety : the msg_block is checked below in verify_msg_block\n            build_msg_block(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        //@safety : the msg_len is checked below in verify_msg_len\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe {\n            //@safety : testing context\n            build_msg_block(input, input.len(), 0)\n        };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe {\n            //@safety : testing context\n            build_msg_block(input, input.len(), 64)\n        };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe {\n            //@safety  : testing context\n            attach_len_to_msg_block(input, 1, 448)\n        };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"55":{"source":"// This file is kept for backwards compatibility.\n#[deprecated]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    crate::hash::sha256::digest(msg)\n}\n\n#[deprecated]\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    crate::hash::sha256::sha256_var(msg, message_size)\n}\n","path":"std/sha256.nr"},"62":{"source":"fn main(prev_hash: pub Field, nonce: Field, solution: Field, _address: pub Field) {\n    let prev_hash_bytes: [u8; 32] = prev_hash.to_le_bytes();\n    let nonce_bytes: [u8; 32] = nonce.to_le_bytes();\n\n    let mut combined_bytes: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        combined_bytes[i] = prev_hash_bytes[i];\n        combined_bytes[i + 32] = nonce_bytes[i];\n    }\n    let hash = std::sha256::sha256_var(combined_bytes, 64);\n    let hash_field: Field = Field::from_be_bytes::<32>(hash);\n\n    println(hash_field);\n\n    assert(hash_field == solution);\n}\n\n#[test]\nfn test_main() {\n    let prev_hash: Field = 0x0;\n    let nonce: Field = 0x0;\n    let address: Field = 0;\n\n    let input_1_bytes: [u8; 8] = prev_hash.to_be_bytes();\n    let input_2_bytes: [u8; 8] = nonce.to_be_bytes();\n\n    let mut combined_bytes: [u8; 16] = [0; 16];\n    for i in 0..8 {\n        combined_bytes[i] = input_1_bytes[i];\n        combined_bytes[i + 8] = input_2_bytes[i];\n    }\n    let hash = std::sha256::sha256_var(combined_bytes, 16);\n    let solution: Field = Field::from_be_bytes::<32>(hash);\n\n\n    main(prev_hash, nonce, solution, address);\n}\n\n#[test]\nfn test_hash() {\n    // test case: input_1 and input_2\n    let input_1: Field = 0x0;\n    let input_2: Field = 0x0;\n\n    // Convert each Field to an 8-byte array in big-endian order\n    let input_1_bytes: [u8; 32] = input_1.to_be_bytes();\n    let input_2_bytes: [u8; 32] = input_2.to_be_bytes();\n\n    let mut combined_bytes: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        combined_bytes[i] = input_1_bytes[i];\n        combined_bytes[i + 32] = input_2_bytes[i];\n    }\n    let hash = std::sha256::sha256_var(combined_bytes, 64);\n    let hash_field: Field = Field::from_be_bytes::<32>(hash);\n\n    let zero = 0;\n\n    println(zero);\n    // Print out for debugging\n    println(\"input_1 bytes:\");\n    println(input_1_bytes);\n    println(\"input_2 bytes:\");\n    println(input_2_bytes);\n    println(\"combined:\");\n    println(combined_bytes);\n    println(\"hash:\");\n    println(hash);\n    println(hash_field);\n}\n","path":"/Users/riemann/Desktop/hashcash/circuits/src/main.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_to_radix","directive_invert","directive_integer_quotient"]}